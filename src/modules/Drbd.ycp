/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Drbd.ycp
 * Package:	Configuration of drbd
 * Summary:	Drbd settings, input and output functions
 * Authors:	xwhu <xwhu@novell.com>
 *
 * $Id: Drbd.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of drbd.
 * Input and output routines.
 */

{

module "Drbd";
textdomain "drbd";

import "Popup";
import "Progress";
import "Report";
import "Summary";
import "Service";

import "Mode";
import "PackageSystem";

global boolean proposal_valid = false;
global boolean modified = false;
global map global_config = $[];
global map resource_config = $[];
global string drbd_dir = "/etc";
global boolean start_daemon = false;
global map<string, list<string> > config_name = $["disk_s":["on-io-error", "size"],
	   "syncer":["rate", "al-extents"],
	   "net":["timeout", "connect-int", "ping-int", "max-buffers", "unplug-watermark", "max-epoch-size", "sndbuf-size", "ko-count"],
	   "startup":["wfc-timeout", "degr-wfc-timeout"]];

global string global_error = "";

boolean prepare_conf_file()
{
	string merge_script = "
		pushd " + drbd_dir + " > /dev/null 2>&1
		cat drbd.conf | while read line; do
			s=`echo $line | awk '{print $1}'`;
			if [[ x$s =~ xinclude ]]; then
				cat `echo $line | sed 's/include//' | sed 's/;//g' | sed 's/\"//g'`;
			else
				echo $line;
			fi
		done > drbd.conf.YaST2prepare 
		popd > /dev/null 2>&1
	";

	if (SCR::Execute(.target.bash, "/usr/bin/grep '^[ \t]*include' " + drbd_dir + "/drbd.conf") == 0) {
		map out = (map) SCR::Execute(.target.bash_output, merge_script);
		if (out["exit"]:0 != 0 || size(out["stderr"]:"") != 0) {
			global_error = _("Failed to merge separated DRBD conf files\n") + out["stderr"]:"";
			y2error("Failed to merge separated DRBD conf files:\n%1", out);
			return false;
		}
	} else {
		any r = SCR::Execute(.target.bash, "/bin/cp " + drbd_dir + "/drbd.conf " + drbd_dir + "/drbd.conf.YaST2prepare");
		if (r != 0) {
			y2error("Failed to write drbd.conf.YaST2prepare");
			global_error = _("Failed to write drbd.conf.YaST2prepare");
			return false;
		}
	}

	return true;
}

global boolean Read() {
    /* DRBD read dialog caption */
    string caption = _("Initializing DRBD Configuration");

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", 4, [
            _("Read global settings"),
            _("Read resources"),
            _("Read daemon status")
    ], [
    _("Reading global settings..."),
    _("Reading resources..."),
    _("Reading daemon status..."),
    _("Finished")
    ],
    ""
    );

    Progress::NextStage();

    // check installed packages
    // find out which krbd-kmp-<arch> to be installed
    map out = (map) SCR::Execute(.target.bash_output,
		"echo -n `uname -r|grep -Eo \"default|smp|bigsmp|desktop|pae|xen|xenpae|debug|ppc64|iseries64\"`");
    string krbd_kmp_arch= out["stdout"]:"default";

    if (!Mode::test() && !PackageSystem::CheckAndInstallPackagesInteractive(["drbd", "drbd-kmp-" + krbd_kmp_arch]))
    {
        return false;
    }

    if (SCR::Read(.target.size, drbd_dir + "/drbd.conf") > 0)
	{
	        y2milestone("DRBD conf file is %1/drbd.conf", drbd_dir);

		if (prepare_conf_file() == false)
			return false;

/*
		//merge include file
		if (SCR::Execute(.target.bash, "/usr/bin/grep '^[ \t]*include' " + drbd_dir + "/drbd.conf") == 0)
		{
			if (Popup::YesNo(_("Warning: YaST2 DRBD module will rename all included files ") +
				_(" for DRBD into a supported schema. Do you want to continue?")))
			{
				string merge_script = "
                       pushd " + drbd_dir + " > /dev/null 2>&1
                       cat drbd.conf | while read line; do
                         s=`echo $line | awk '{print $1}'`;
                         if [[ x$s =~ xinclude ]]; then
                            cat `echo $line | sed 's/include//' | sed 's/;//g' | sed 's/\"//g'`;
                         else
                            echo $line;
                         fi
                       done > drbd.conf.YaST2prepare 
                       popd > /dev/null 2>&1
				";
				map out = (map) SCR::Execute(.target.bash_output, merge_script);
				if (out["exit"]:0 != 0 || size(out["stderr"]:"") != 0)
				{
					y2error("Failed to merge separated configuration files:\n	exit code = %1\n	stderr = %2", out["exit"]:0, out["stderr"]:"");
					Popup::Error(_("Failed to merge separated configuration files."));
					return false;
				}
			}
			else
			{
				return false;
			}
		}
		else
		{
			map out = (map)SCR::Execute(.target.bash, "/bin/cp " + drbd_dir + "/drbd.conf " + drbd_dir + "/drbd.conf.YaST2prepare");
			if (out["exit"]:0 != 0) {
				y2error("Failed to prepare drbd.conf for reading");
				return false;
			}
		}

		map out = (map)SCR::Execute(.target.bash_output, "/bin/mkdir -p " + drbd_dir + "/drbd.d");
		if (out["exit"]:0 != 0) {
			y2error("Failed to prepare the directory for DRBD");
			return false;
		}
*/

		//read global configs
		foreach (string key, [ "disable-ip-verification", "minor-count", "dialog-refresh"],
		{
		    string val = (string)SCR::Read(topath(sformat(".drbd.global.%1", key)));
		    global_config[key] = val;
		});
		if (global_config["minor-count"]:nil == nil) {
			global_config["minor-count"] = "5";
		}
		if (global_config["dialog-refresh"]:nil == nil) {
			global_config["dialog-refresh"] = "1";
		}

		//read resources configs
		list<string> res_names = (list<string>)SCR::Dir(topath(".drbd.resources"));
		foreach (string resname, res_names,
		{
			map config = $[];
			list<string> res_configs = (list<string>)SCR::Dir(topath(sformat(".drbd.resources.%1", resname)));

			foreach (string resconf, ["protocol"],
			{
				if (contains(res_configs, resconf)) {
					string val = (string)SCR::Read(topath(sformat(".drbd.resources.%1.%2",resname,resconf)));
					config[resconf] = val;
				}
			});

			foreach(string r, list<string> l, config_name,
			{
				if (contains(res_configs, r)) {
					map cf = $[];
					foreach(string k, l,
					{
						string v = (string)SCR::Read(topath(sformat(".drbd.resources.%1.%2.%3",resname,r,k)));
						if (v != nil) {
							cf[k] = v;
							y2debug("%1 %2 %3 is %4", resname, r, k, v);
						}
					});
					if (size(cf) > 0) {
						config[r] = cf;
					}
				}
			});

			if (contains(res_configs, "on")) {
				list<string> nodes = (list<string>)SCR::Dir(topath(sformat(".drbd.resources.%1.on", resname)));
				map nodescf = $[];
				foreach (string n, nodes,
				{
					map nodecf = $[];
					foreach(string k, ["device", "disk", "meta-disk", "address"],
					{
						string v = (string)SCR::Read(topath(sformat(".drbd.resources.%1.on.%2.%3", resname, n, k)));
						if (v != nil) {
							nodecf[k] = v;
							y2debug("%1 on %2 %3 is %4", resname, n, k, v);
						}
					});
					if (size(nodecf) > 0) {
						nodescf[n] = nodecf;
					}
				});
				if (size(nodescf) > 0) {
					config["on"] = nodescf;
				}
			}
			if (size(config) > 0) {
				resource_config[resname] = config;
			}
		});
    } else {
	SCR::Execute(.target.bash, "rm /etc/drbd.conf.YaST2prepare");
        y2milestone("DRBD conf file %1/drbd.conf not found", drbd_dir);
    }

	y2milestone("read resource_config=%1", resource_config);

    Progress::NextStage();
    start_daemon = Service::Enabled("drbd");

    Progress::NextStage();

	modified = false;
    return true;
}

void recursive_write_map(path cur_path, map<string, any> the_map)
{
	foreach (string key, any val, the_map,
	{
		if (is(val, map) && val !=nil)
		{
			SCR::Write(add(cur_path, key), nil);
			recursive_write_map(add(cur_path, key), (map<string, any>) val);
		} else
		{
			y2debug("write conf file: %1=%2", add(cur_path, key), val);
			SCR::Write(add(cur_path, key), val);
		}
	});
}


map del_empty_item(map old_map)
{
    map new_map = old_map;
    foreach (string key, any val, (map<string, any>) old_map,
    {
        if (is(val, map))
        {
            new_map[key] = del_empty_item((map)val);
        } else //if (is(val, string))
        {
            if (size((string)val) == 0)
                new_map[key] = nil;
                //new_map = remove(new_map, key);
        }
    });

    return new_map;
}

void restore_yast_save_files()
{
	SCR::Execute(.target.bash, "/bin/mv /etc/drbd.conf.YaST2save /etc/drbd.conf");
	SCR::Execute(.target.bash, "/usr/bin/rename .YaST2save '' /etc/drbd.d/*.YaST2save");
}

boolean validate_configure()
{
	map out = $[];


	if (SCR::Read(.target.size, "/etc/drbd.conf") < 0)
		return true;

	out = (map) SCR::Execute(.target.bash_output, "/bin/cp /etc/drbd.conf /etc/drbd.conf.bak");
	if (out["exit"]:0 != 0) {
		global_error = _("Failed to backup drbd.conf");
		y2error("Failed to backup drbd.conf\n %1", out);
		return false;
	}

	out = (map) SCR::Execute(.target.bash_output, "/bin/echo>/etc/drbd.conf");
	if (out["exit"]:0 != 0) {
		global_error = _("Failed to clean drbd.conf for drbdadm test");
		y2error("Failed to clean drbd.conf for drbdadm test\n%1", out);
		return false;
	}

	y2milestone("drbdadm res=%1", resource_config);
	any r = foreach (string key, any val, (map<string, any>) resource_config,
	{
		out = (map) SCR::Execute(.target.bash_output, "/sbin/drbdadm -t /etc/drbd.d/" + key + ".res sh-nop");
		if (out["exit"]:0 != 0) {
			global_error = sformat(_("Invalid configuration of resource %1\n%2"), key, out["stderr"]:"");
			y2error("Invalid configuration of resource %1\n%2", key, out);
			return false;
		}
	});

	if (r == false) return false;

	if ((SCR::Read(.target.size, "/etc/drbd.conf.bak") >= 0) &&
		(SCR::Execute(.target.bash, "/bin/mv /etc/drbd.conf.bak /etc/drbd.conf") != 0))
	{
		global_error = _("Failed to bring drbd.conf back");
		y2error("Failed to bring drbd.conf back");
		return false;
	}

	return true;
}

global boolean Write() {
	/* DRBD write dialog caption */
	string caption = _("Writing DRBD Configuration");

	//if (!modified) return true;

	// We do not set help text here, because it was set outside
	Progress::New( caption, " ", 4, 
		[
			_("Write global settings"),
			_("Write resources"),
			_("Set daemon status")
		],
		[
			_("Writing global settings..."),
			_("Writing resources..."),
			_("Setting daemon status..."),
			_("Finished")
		],
		""
	);


	if (SCR::Execute(.target.bash, "/bin/mkdir -p " + drbd_dir + "/drbd.d") != 0) {
		global_error = _("Failed to make directory /etc/drbd.d");
		y2error("Failed to make directory /etc/drbd.d");
		return false;
	}

	//global config here
	Progress::NextStage();
	y2debug("to write global config: global_config=%1", global_config);
	foreach(string key, [ "disable-ip-verification", "minor-count", "dialog-refresh" ],
	{
		if (global_config[key]:nil != nil) {
			SCR::Write(topath(sformat(".drbd.global.%1", key)), global_config[key]:nil);
		}
	});

	//resource config here
	Progress::NextStage();
	resource_config = del_empty_item(resource_config);
	recursive_write_map(.drbd.resources, (map<string, any>)resource_config);
	y2debug("to write resource config: resource_config=%1", resource_config);

	SCR::Write(topath(".drbd"), "");

	if (validate_configure() == false) {
		restore_yast_save_files();
		return false;
	}

	Progress::NextStage();
	if (start_daemon) {
		Service::Enable("drbd");
		if (Service::Status("drbd") == 0)
			Service::Restart("drbd");
		else
			Service::Start("drbd");
	}
	else {
		Service::Disable("drbd");
		Service::Stop("drbd");
	}
	Progress::NextStage();

    return true;
}

}
